{
	"nodes":[
		{"id":"1a6e7908f6512b7b","type":"group","x":880,"y":80,"width":1720,"height":4120,"color":"3","label":"In chain circuit"},
		{"id":"549c8343762a0fe1","type":"group","x":-2400,"y":920,"width":3080,"height":2000,"color":"4","label":"Client"},
		{"id":"3a28c2973eff41ad","type":"text","text":"### Reciever: *Ciphertext*, *Public key sender*\n","x":2310,"y":660,"width":250,"height":60},
		{"id":"e869d77d7b06d825","type":"text","text":"### Public Inputs\n**Input UTXOs**\n**Output UTXOs**\n**Encryption Nonce**","x":1568,"y":120,"width":250,"height":157,"color":"4"},
		{"id":"e7d5225131d40993","type":"text","text":"- **Encrypted Data**:\n\t- Uses **ECDH** to compute a shared secret: `shared_secret = ECDH(privKey_A, pubKey_B)`.\n\t- Encrypts `(value=10, salt_B)` with `shared_secret` and a `nonce`.\n\t- Generates `encryptedValues` (e.g., `[encrypted_value, encrypted_salt, parity_bit]`).","x":1698,"y":410,"width":250,"height":60},
		{"id":"bc994cca5bf88ba2","type":"text","text":"### Validity : *{0, 1}*","x":2060,"y":530,"width":250,"height":60,"color":"1"},
		{"id":"6cfed619baad930e","type":"text","text":"### Setup\nWe get the deployer, three users and circuit for proofs\n```ts\nlet [d, a, b, c] = await ethers.getSigners();\ndeployer = d;\nAlice = await newUser(a);\nBob = await newUser(b);\nCharlie = await newUser(c);\n\n({ deployer, zeto, erc20 } = await deployZeto(\"Zeto_AnonEnc\"));\n\ncircuit = await loadCircuit(\"anon_enc\");\n({ provingKeyFile: provingKey } = loadProvingKeys(\"anon_enc\"));\n```","x":-1160,"y":960,"width":1240,"height":400},
		{"id":"87a3933ebded28ff","type":"text","text":"### Transaction\n*Mint to Alice and transfer UTXOs honestly to Bob*\nFirst the authority mints UTXOs to Alice\n```ts\nconst startingBalance = await erc20.balanceOf(Alice.ethAddress);\n// first the authority mints UTXOs to Alice\nutxo1 = newUTXO(10, Alice);\nutxo2 = newUTXO(20, Alice);\nawait doMint(zeto, deployer, [utxo1, utxo2]);\n```\nThen Alice creates new UTXOs and initiate the transfer\n```ts\n// Alice proposes the output UTXOs\nconst _txo3 = newUTXO(25, Bob);\nutxo4 = newUTXO(5, Alice, _txo3.salt);\n\n// Alice transfers UTXOs to Bob\nconst result = await doTransfer(\n  Alice,\n  [utxo1, utxo2],\n  [_txo3, utxo4],\n  [Bob, Alice],\n);\n```\nBob obtain the UTXO from the transaction event \n```ts\n// first obtain the UTXOs from the transaction event\nconst events = parseUTXOEvents(zeto, result);\nconst incomingUTXOs: any = events[0].outputs;\n```\n\nBob reconstructs the shared key and decrypts the message\n```ts\nconst ecdhPublicKey = events[0].ecdhPublicKey;\n// Bob reconstructs the shared key using his private key and ephemeral public key\n\nconst sharedKey = genEcdhSharedKey(Bob.babyJubPrivateKey, ecdhPublicKey);\nconst plainText = poseidonDecrypt(\n\tevents[0].encryptedValues.slice(0, 4),\n\tsharedKey,\n\tevents[0].encryptionNonce,\n\t2,\n);\n```\n\n\nWith the decrypted message Bob can compute the hash of his UTXO and the computed `hash` should be equal to the UTXO obained from the events\n```ts\nconst hash = poseidonHash([\n\tBigInt(plainText[0]),\n\tplainText[1],\n\tBob.babyJubPublicKey[0],\n\tBob.babyJubPublicKey[1],\n]);\n\nexpect(incomingUTXOs[0]).to.equal(hash);\nutxo3 = newUTXO(Number(plainText[0]), Bob, plainText[1]);\n```","x":-600,"y":1400,"width":1240,"height":1340},
		{"id":"5d60cbd12fc9537d","type":"text","text":"### doTransfer\n```ts\nasync function doTransfer(\n    signer: User,\n    inputs: UTXO[],\n    outputs: UTXO[],\n    owners: User[],\n  ) {\n    let inputCommitments: BigNumberish[];\n    let outputCommitments: BigNumberish[];\n    let encryptedValues: BigNumberish[];\n    let encryptionNonce: BigNumberish;\n    let encodedProof: any;\n    const ephemeralKeypair = genKeypair();\n    const result = await prepareProof(\n      signer,\n      inputs,\n      outputs,\n      owners,\n      ephemeralKeypair.privKey,\n    );\n    inputCommitments = result.inputCommitments;\n    outputCommitments = result.outputCommitments;\n    encodedProof = result.encodedProof;\n    encryptedValues = result.encryptedValues;\n    encryptionNonce = result.encryptionNonce;\n\n    const txResult = await sendTx(\n      signer,\n      inputCommitments,\n      outputCommitments,\n      encryptedValues,\n      encryptionNonce,\n      encodedProof,\n      ephemeralKeypair.pubKey,\n    );\n    // add the clear text value so that it can be used by tests to compare with the decrypted value\n    return {\n      txResult,\n      expectedPlainText: outputs.reduce((acc, o, i) => {\n        acc.push(BigInt(o.value || 0n) as BigNumberish);\n        acc.push((o.salt || 0n) as BigNumberish);\n        return acc;\n      }, [] as BigNumberish[]),\n    };\n  }\n```","x":-1440,"y":1565,"width":680,"height":1010},
		{"id":"e4c9d9b9ad494171","type":"text","text":"### Prepare proof\n```ts\nasync function prepareProof(\n    signer: User,\n    inputs: UTXO[],\n    outputs: UTXO[],\n    owners: User[],\n    ephemeralPrivateKey: BigInt,\n  ) {\n    const inputCommitments: BigNumberish[] = inputs.map(\n      (input) => input.hash,\n    ) as BigNumberish[];\n    const inputValues = inputs.map((input) => BigInt(input.value || 0n));\n    const inputSalts = inputs.map((input) => input.salt || 0n);\n    const outputCommitments: BigNumberish[] = outputs.map(\n      (output) => output.hash,\n    ) as BigNumberish[];\n    const outputValues = outputs.map((output) => BigInt(output.value || 0n));\n    const outputOwnerPublicKeys: BigNumberish[][] = owners.map(\n      (owner) => owner.babyJubPublicKey,\n    ) as BigNumberish[][];\n    const encryptionNonce: BigNumberish = newEncryptionNonce() as BigNumberish;\n    const encryptInputs = stringifyBigInts({\n      encryptionNonce,\n      ecdhPrivateKey: formatPrivKeyForBabyJub(ephemeralPrivateKey),\n    });\n\n    let circuitToUse = circuit;\n    let provingKeyToUse = provingKey;\n    let isBatch = false;\n    if (inputCommitments.length > 2 || outputCommitments.length > 2) {\n      isBatch = true;\n      circuitToUse = batchCircuit;\n      provingKeyToUse = batchProvingKey;\n    }\n    const startWitnessCalculation = Date.now();\n    const witness = await circuitToUse.calculateWTNSBin(\n      {\n        inputCommitments,\n        inputValues,\n        inputSalts,\n        inputOwnerPrivateKey: formatPrivKeyForBabyJub(signer.babyJubPrivateKey),\n        outputCommitments,\n        outputValues,\n        outputSalts: outputs.map((output) => output.salt || 0n),\n        outputOwnerPublicKeys,\n        ...encryptInputs,\n      },\n      true,\n    );\n    const timeWitnessCalculation = Date.now() - startWitnessCalculation;\n\n    const startProofGeneration = Date.now();\n    const { proof, publicSignals } = (await groth16.prove(\n      provingKeyToUse,\n      witness,\n    )) as { proof: BigNumberish[]; publicSignals: BigNumberish[] };\n    const timeProofGeneration = Date.now() - startProofGeneration;\n    console.log(\n      `Witness calculation time: ${timeWitnessCalculation}ms, Proof generation time: ${timeProofGeneration}ms`,\n    );\n\n    // console.log(publicSignals);\n    const encodedProof = encodeProof(proof);\n    const encryptedValues = isBatch\n      ? publicSignals.slice(2, 42)\n      : publicSignals.slice(2, 10);\n    return {\n      inputCommitments,\n      outputCommitments,\n      encryptedValues,\n      encryptionNonce,\n      encodedProof,\n    };\n  }\n```","x":-2360,"y":1278,"width":775,"height":1585},
		{"id":"55bb152d7b6f4374","type":"text","text":"```c\ntemplate Zeto(nInputs, nOutputs) {\n\t//Public-------------------------------------\n\tsignal input inputCommitments[nInputs];\n\tsignal input outputCommitments[nOutputs];\n\tsignal input encryptionNonce;\n\t//-------------------------------------------\n\n\t//Private------------------------------------\n\tsignal input inputValues[nInputs];\n\tsignal input inputSalts[nInputs];\n\tsignal input outputValues[nOutputs];\n\tsignal input outputSalts[nOutputs];\n\t\n\tsignal input outputOwnerPublicKeys[nOutputs][2];\n\tsignal input inputOwnerPrivateKey;\n\t\n\tsignal input ecdhPrivateKey;\n\t//-------------------------------------------\n\n\t//Output-------------------------------------\n\t// the output for the public key of the ephemeral private key used in generating ECDH shared key\n\tsignal output ecdhPublicKey[2];\n\t\n\t// the output for the list of encrypted output UTXOs cipher texts\n\tsignal output cipherTexts[nOutputs][4];\n\t//-------------------------------------------\n\t\n\t//Get the public owner key fom it's private key\n\tvar inputOwnerPubKeyAx, inputOwnerPubKeyAy;\n\t(inputOwnerPubKeyAx, inputOwnerPubKeyAy) = BabyPbk()(in <== inputOwnerPrivateKey);\n\tvar inputOwnerPublicKeys[nInputs][2];\n\tfor (var i = 0; i < nInputs; i++) {\n\t\tinputOwnerPublicKeys[i]= [inputOwnerPubKeyAx, inputOwnerPubKeyAy];\n\t}\n\t//-------------------------------------------\n\t\n\tCheckPositive(nOutputs)(outputValues <== outputValues);\n\tCheckHashes(nInputs)(commitments <== inputCommitments, values <== inputValues, salts <== inputSalts, ownerPublicKeys <== inputOwnerPublicKeys);\n\tCheckHashes(nOutputs)(commitments <== outputCommitments, values <== outputValues, salts <== outputSalts, ownerPublicKeys <== outputOwnerPublicKeys);\n\tCheckSum(nInputs, nOutputs)(inputValues <== inputValues, outputValues <== outputValues);\n\t(ecdhPublicKey,cipherTexts ) <== EncryptOutputs(nOutputs)(ecdhPrivateKey <== ecdhPrivateKey, outputValues <== outputValues, outputSalts <== outputSalts, outputOwnerPublicKeys <== outputOwnerPublicKeys, encryptionNonce <== encryptionNonce);\n}\n```","x":1060,"y":820,"width":1300,"height":940},
		{"id":"6c58fcbf31c49169","type":"text","text":"### Private Inputs\n**Input values, salt**\n**Output values, salt**\n**Sender Private Key**\n**Receiver Public key**","x":1080,"y":460,"width":250,"height":200,"color":"4"},
		{"id":"3595e3c44bb694e2","type":"text","text":"### Anon Circuit\n#### Compute\n```\n(sender_pub_k) <- sender_private_key\nInput_UTXO' = hash(value_in, salt, sender_pub_k)\nOutput_UTXO' = hash(value_out, salt, sender_pub_k/receiver_pub_k)\nShared_key = ECDH(sender_private_key, receiver_pub_k)\nCiphertext = E(Value, Salt, Shared_key, Nonce)\n```\n#### Verify\n```\nInput_UTXO' == Input_UTXO\nOutput_UTXO' == Output_UTXO\nvalue_in == value_out\nsender_pub -> sender_private_key\n```\n","x":1385,"y":320,"width":615,"height":480,"color":"3"},
		{"id":"39facfc227ee61a5","type":"text","text":"### CheckHashes\nCalculate the hash depending on the values, salts, public key and compare it to the commitment \n```c\ntemplate CheckHashes(numInputs) {\n\tsignal input commitments[numInputs];\n\tsignal input values[numInputs];\n\tsignal input salts[numInputs];\n\tsignal input ownerPublicKeys[numInputs][2];\n\t\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tvar calculatedHash;\n\t\tcalculatedHash = Poseidon(4)([values[i], salts[i], ownerPublicKeys[i][0], ownerPublicKeys[i][1]]);\n\t\t\n\t\t// check that the input commitments match the calculated hashes\n\t\tvar isCommitmentZero;\n\t\tisCommitmentZero = IsZero()(in <== commitments[i]);\n\t\t\n\t\tvar isHashEqual;\n\t\tisHashEqual = IsEqual()(in <== [commitments[i], (1 - isCommitmentZero) * calculatedHash /* ensure when commitment is 0, compare with 0 */]);\n\t\t\n\t\tisHashEqual === 1;\n\t}\n}\n\n```","x":1060,"y":2240,"width":1260,"height":600},
		{"id":"0a3e7599082fd8bb","type":"text","text":"### CheckSum\nCheck that the sum of input equals to the sum of output\n```c\ntemplate CheckSum(numInputs, numOutputs) {\n\tsignal input inputValues[numInputs];\n\tsignal input outputValues[numOutputs];\n\t\n\tvar sumInputs = 0;\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tsumInputs = sumInputs + inputValues[i];\n\t}\n\tvar sumOutputs = 0;\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tsumOutputs = sumOutputs + outputValues[i];\n\t}\n\t\n\tvar isSumEqual;\n\tisSumEqual = IsEqual()(in <== [sumInputs, sumOutputs]);\n\t\n\tisSumEqual === 1;\n}\n```","x":1060,"y":2880,"width":580,"height":520},
		{"id":"64e86bd07fccf4ea","type":"text","text":"### EncryptOutputs\nEncrypt the values and salts with en nonce thanks to the private key public keys\n```c\ntemplate EncryptOutputs(numOutputs) {\n  signal input ecdhPrivateKey;\n  signal input encryptionNonce;\n  signal input outputValues[numOutputs];\n  signal input outputSalts[numOutputs];\n  signal input outputOwnerPublicKeys[numOutputs][2];\n  \n  // the output for the public key of the ephemeral private key used in generating ECDH shared key\n  signal output ecdhPublicKey[2];\n\n  // the output for the list of encrypted output UTXOs cipher texts\n  signal output cipherTexts[numOutputs][4];\n\n  for (var i = 0; i < numOutputs; i++) {\n    // generate shared secret\n    var sharedSecret[2];\n    sharedSecret = Ecdh()(privKey <== ecdhPrivateKey, pubKey <== outputOwnerPublicKeys[i]);\n\n    // encrypt the value for the output UTXOs\n    cipherTexts[i] <== SymmetricEncrypt(2)(plainText <== [outputValues[i], outputSalts[i]], key <== sharedSecret, nonce <== encryptionNonce);\n  }\n\n  (ecdhPublicKey[0], ecdhPublicKey[1]) <== BabyPbk()(in <== ecdhPrivateKey);\n}\n\n```","x":1060,"y":3440,"width":860,"height":720},
		{"id":"537c8e799ec7f071","type":"text","text":"### CheckPositive\nCheck is the value is greater or equal to `0` \n```c\ntemplate CheckPositive(numOutputs) {\n\tsignal input outputValues[numOutputs];\n\t\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tvar greaterEqThanZero;\n\t\tgreaterEqThanZero = GreaterEqThan(100)(in <== [outputValues[i], 0]);\n\t\t\n\t\tgreaterEqThanZero === 1;\n\t}\n}\n```","x":1060,"y":1800,"width":580,"height":400},
		{"id":"a8ccc2a6a5198c5d","type":"text","text":"**Private key**\n","x":2760,"y":1920,"width":160,"height":52},
		{"id":"1481939b6e4dafb0","type":"text","text":"### Alice","x":2862,"y":1820,"width":156,"height":60},
		{"id":"7d9d5cf3575e4850","type":"text","text":"**Public key**\n","x":2960,"y":1920,"width":160,"height":52},
		{"id":"64b44ee3faf352aa","type":"text","text":"**Private key**\n","x":3180,"y":1920,"width":160,"height":52},
		{"id":"3dc98b5a3163f68a","type":"text","text":"### Ephemeral","x":3280,"y":1820,"width":163,"height":60},
		{"id":"bb0841a99c942fb0","type":"text","text":"**Public key**\n","x":3380,"y":1920,"width":160,"height":52},
		{"id":"260ecb7833d0fac1","type":"text","text":"**Private key**\n","x":3660,"y":1920,"width":160,"height":52},
		{"id":"332da104c54c47c0","type":"text","text":"### Bob","x":3762,"y":1820,"width":156,"height":60},
		{"id":"73d78d3db1127685","type":"text","text":"**Public key**\n","x":3860,"y":1920,"width":160,"height":52},
		{"id":"59341dde6bcb80a8","type":"text","text":"### Shared Key","x":3520,"y":2060,"width":157,"height":60,"color":"3"}
	],
	"edges":[
		{"id":"b55004d7a27bd095","fromNode":"3595e3c44bb694e2","fromSide":"right","toNode":"bc994cca5bf88ba2","toSide":"left"},
		{"id":"5f72d523acaa299b","fromNode":"e869d77d7b06d825","fromSide":"bottom","toNode":"3595e3c44bb694e2","toSide":"top"},
		{"id":"eb51cb0c137cf34d","fromNode":"6c58fcbf31c49169","fromSide":"right","toNode":"3595e3c44bb694e2","toSide":"left"},
		{"id":"ecb80283b839b374","fromNode":"bc994cca5bf88ba2","fromSide":"bottom","toNode":"3a28c2973eff41ad","toSide":"left","label":"1"},
		{"id":"e6efe6e5ba077bdf","fromNode":"55bb152d7b6f4374","fromSide":"left","toNode":"537c8e799ec7f071","toSide":"left"},
		{"id":"450cd3cb6e5d9988","fromNode":"55bb152d7b6f4374","fromSide":"left","toNode":"39facfc227ee61a5","toSide":"left"},
		{"id":"c759a89907a6f13b","fromNode":"55bb152d7b6f4374","fromSide":"left","toNode":"0a3e7599082fd8bb","toSide":"left"},
		{"id":"98349ab5cb604ef3","fromNode":"5d60cbd12fc9537d","fromSide":"left","toNode":"e4c9d9b9ad494171","toSide":"right"},
		{"id":"8a550ac033cab644","fromNode":"87a3933ebded28ff","fromSide":"left","toNode":"5d60cbd12fc9537d","toSide":"right"},
		{"id":"c958bfce930edc1b","fromNode":"55bb152d7b6f4374","fromSide":"left","toNode":"64e86bd07fccf4ea","toSide":"left"},
		{"id":"56fbb42b5657ba54","fromNode":"1481939b6e4dafb0","fromSide":"bottom","toNode":"a8ccc2a6a5198c5d","toSide":"top"},
		{"id":"4c3928b59fa5ea99","fromNode":"1481939b6e4dafb0","fromSide":"bottom","toNode":"7d9d5cf3575e4850","toSide":"top"},
		{"id":"1b138ff655b70fb4","fromNode":"332da104c54c47c0","fromSide":"bottom","toNode":"260ecb7833d0fac1","toSide":"top"},
		{"id":"9f8907631569c03e","fromNode":"332da104c54c47c0","fromSide":"bottom","toNode":"73d78d3db1127685","toSide":"top"},
		{"id":"d259ae0305f2683c","fromNode":"3dc98b5a3163f68a","fromSide":"bottom","toNode":"64b44ee3faf352aa","toSide":"top"},
		{"id":"5ce5b139b9c79f0e","fromNode":"3dc98b5a3163f68a","fromSide":"bottom","toNode":"bb0841a99c942fb0","toSide":"top"},
		{"id":"4b7d41f57f0be8f4","fromNode":"1481939b6e4dafb0","fromSide":"right","toNode":"3dc98b5a3163f68a","toSide":"left","label":"Generates"},
		{"id":"222232e0e105caef","fromNode":"260ecb7833d0fac1","fromSide":"bottom","toNode":"59341dde6bcb80a8","toSide":"right"},
		{"id":"1b117d412f588484","fromNode":"bb0841a99c942fb0","fromSide":"bottom","toNode":"59341dde6bcb80a8","toSide":"left"},
		{"id":"f2bda32b36584cc8","fromNode":"64b44ee3faf352aa","fromSide":"bottom","toNode":"59341dde6bcb80a8","toSide":"left"},
		{"id":"de8184dbe40fe8d7","fromNode":"73d78d3db1127685","fromSide":"bottom","toNode":"59341dde6bcb80a8","toSide":"right"}
	]
}