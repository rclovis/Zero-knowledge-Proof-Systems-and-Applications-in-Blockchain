{
	"nodes":[
		{"id":"0379b118349d1f2e","type":"group","x":-2080,"y":1820,"width":3080,"height":3020,"color":"4","label":"Client"},
		{"id":"441aebf4bb8350f5","type":"group","x":1200,"y":1300,"width":1500,"height":4800,"color":"3","label":"In chain circuit"},
		{"id":"dd128cf805716a06","type":"text","text":"### Setup\nWe get the deployer, three users and circuit for proofs\n```ts\nlet [d, a, b, c] = await ethers.getSigners();\ndeployer = d;\nAlice = await newUser(a);\nBob = await newUser(b);\nCharlie = await newUser(c);\n\n({ deployer, zeto, erc20 } = await deployZeto(\"Zeto_AnonNullifier\"));\n\nconst storage1 = new InMemoryDB(str2Bytes(\"\"));\nsmtAlice = new Merkletree(storage1, true, 64);\n\nconst storage2 = new InMemoryDB(str2Bytes(\"\"));\nsmtBob = new Merkletree(storage2, true, 64);\n\ncircuit = await loadCircuit(\"anon_nullifier_transfer\");\n({ provingKeyFile: provingKey } = loadProvingKeys(\n  \"anon_nullifier_transfer\",\n));\n```","x":-780,"y":2200,"width":1240,"height":540},
		{"id":"d77fb10724b7e356","type":"text","text":"### Transaction\n*Mint to Alice and transfer UTXOs honestly to Bob*\nFirst the authority mints UTXOs to Alice\n```ts\nconst startingBalance = await erc20.balanceOf(Alice.ethAddress);\n// first the authority mints UTXOs to Alice\nutxo1 = newUTXO(10, Alice);\nutxo2 = newUTXO(20, Alice);\nawait doMint(zeto, deployer, [utxo1, utxo2]);\n```\nThe two input UTXO are in Alice's and Bob's Merkel tree\n```ts\n// Alice locally tracks the UTXOs inside the Sparse Merkle Tree\nconst mintEvents = parseUTXOEvents(zeto, result1);\nconst [_utxo1, _utxo2] = mintEvents[0].outputs;\nawait smtAlice.add(_utxo1, _utxo1);\nawait smtAlice.add(_utxo2, _utxo2);\nlet root = await smtAlice.root();\nlet onchainRoot = await zeto.getRoot();\n// Bob also locally tracks the UTXOs inside the Sparse Merkle Tree\nawait smtBob.add(_utxo1, _utxo1);\nawait smtBob.add(_utxo2, _utxo2);\n```\nThen Alice creates new UTXOs and initiate the transfer\n```ts\n// Alice proposes the output UTXOs\nconst _utxo3 = newUTXO(25, Bob);\nutxo4 = newUTXO(5, Alice);\n\nconst nullifier1 = newNullifier(utxo1, Alice);\nconst nullifier2 = newNullifier(utxo2, Alice);\n```\nWe generate proofs for the UTXO in the merkel tree\n```ts\n// Alice generates inclusion proofs for the UTXOs to be spent\nconst proof1 = await smtAlice.generateCircomVerifierProof(utxo1.hash, root);\nconst proof2 = await smtAlice.generateCircomVerifierProof(utxo2.hash, root);\nconst merkleProofs = [\n\tproof1.siblings.map((s) => s.bigInt()),\n\tproof2.siblings.map((s) => s.bigInt()),\n];\n```\nInitiate the transfer\n```ts\nconst result2 = await doTransfer(\n\tAlice,\n\t[utxo1, utxo2],\n\t[nullifier1, nullifier2],\n\t[_utxo3, utxo4],\n\troot.bigInt(),\n\tmerkleProofs,\n\t[Bob, Alice],\n);\n```\nBob and Alice can now add these new UTXO to their local merkel tree \n```ts\nawait smtAlice.add(_utxo3.hash, _utxo3.hash);\nawait smtAlice.add(utxo4.hash, utxo4.hash);\nroot = await smtAlice.root();\nonchainRoot = await zeto.getRoot();\n\nconst events = parseUTXOEvents(zeto, result2.txResult!);\nawait smtBob.add(events[0].outputs[0], events[0].outputs[0]);\nawait smtBob.add(events[0].outputs[1], events[0].outputs[1]);\n```\nBob obtain the UTXO from the transaction event and reconstruct them from off-chain secure message channels with Alice\n```ts\nconst receivedValue = _utxo3.value!;\nconst receivedSalt = _utxo3.salt;\nconst incomingUTXOs: any = events[0].outputs;\nconst hash = Poseidon.poseidon4([\n\tBigInt(receivedValue),\n\treceivedSalt,\n\tBob.babyJubPublicKey[0],\n\tBob.babyJubPublicKey[1],\n]);\n```\nThe computed `hash` by Bob should be equal to the UTXO obained from the events\n```ts\nexpect(incomingUTXOs[0]).to.equal(hash);\n\n// Bob uses the decrypted values to construct the UTXO received from the transaction\nutxo3 = newUTXO(receivedValue, Bob, receivedSalt);\n```","x":-280,"y":2780,"width":1240,"height":2040},
		{"id":"78e4cbe0b7e16d4d","type":"text","text":"```c\ntemplate Zeto(nInputs, nOutputs, nSMTLevels) {\n\t//Public-------------------------------------\n\tsignal input nullifiers[nInputs];\n\tsignal input outputCommitments[nOutputs];\n\tsignal input enabled[nInputs];\n\tsignal input root;\n\t//-------------------------------------------\n\t\n\t//Private------------------------------------\n\tsignal input inputCommitments[nInputs];\n\tsignal input inputValues[nInputs];\n\tsignal input inputSalts[nInputs];\n\tsignal input outputValues[nOutputs];\n\tsignal input outputSalts[nOutputs];\n\t\n\tsignal input outputOwnerPublicKeys[nOutputs][2];\n\tsignal input inputOwnerPrivateKey;\n\t\n\tsignal input smtNodeValues[nInputs];\n\tsignal input merkleProof[nInputs][nSMTLevels];\n\t//-------------------------------------------\n\t\n\t//Get the public owner key fom it's private key\n\tvar inputOwnerPubKeyAx, inputOwnerPubKeyAy;\n\t(inputOwnerPubKeyAx, inputOwnerPubKeyAy) = BabyPbk()(in <== inputOwnerPrivateKey);\n\t\n\tvar inputOwnerPublicKeys[nInputs][2];\n\tfor (var i = 0; i < nInputs; i++) {\n\t\tinputOwnerPublicKeys[i] = [inputOwnerPubKeyAx, inputOwnerPubKeyAy];\n\t}\n\t//-------------------------------------------\n\t\n\tCheckPositive(nOutputs)(outputValues <== outputValues);\n\tCheckHashes(nInputs)(commitments <== inputCommitments, values <== inputValues, salts <== inputSalts, ownerPublicKeys <== inputOwnerPublicKeys);\n\tCheckHashes(nOutputs)(commitments <== outputCommitments, values <== outputValues, salts <== outputSalts, ownerPublicKeys <== outputOwnerPublicKeys);\n\tCheckNullifiers(nInputs)(nullifiers <== nullifiers, values <== inputValues, salts <== inputSalts, ownerPrivateKey <== inputOwnerPrivateKey);\n\tCheckSum(nInputs, nOutputs)(inputValues <== inputValues, outputValues <== outputValues);\n\t\n\t// With the above steps, we demonstrated that the nullifiers\n\t// are securely bound to the input commitments. Now we need to\n\t// demonstrate that the input commitments belong to the Sparse\n\t// Merkle Tree with the root `root`.\n\tCheckSMTProof(nInputs, nSMTLevels)(root <== root, merkleProof <== merkleProof, enabled <== enabled, leafNodeIndexes <== inputCommitments, leafNodeValues <== smtNodeValues);\n}\n\n```","x":1380,"y":2180,"width":1300,"height":980},
		{"id":"b488df16e3759c68","type":"text","text":"### CheckPositive\nCheck is the value is greater or equal to `0` \n```c\ntemplate CheckPositive(numOutputs) {\n\tsignal input outputValues[numOutputs];\n\t\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tvar greaterEqThanZero;\n\t\tgreaterEqThanZero = GreaterEqThan(100)(in <== [outputValues[i], 0]);\n\t\t\n\t\tgreaterEqThanZero === 1;\n\t}\n}\n```","x":1380,"y":3200,"width":580,"height":400},
		{"id":"eaa67def5447bb78","type":"text","text":"### CheckHashes\nCalculate the commitment hash depending on the values, salts, public key and compare it to the commitment \n```c\ntemplate CheckHashes(numInputs) {\n\tsignal input commitments[numInputs];\n\tsignal input values[numInputs];\n\tsignal input salts[numInputs];\n\tsignal input ownerPublicKeys[numInputs][2];\n\t\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tvar calculatedHash;\n\t\tcalculatedHash = Poseidon(4)([values[i], salts[i], ownerPublicKeys[i][0], ownerPublicKeys[i][1]]);\n\t\t\n\t\t// check that the input commitments match the calculated hashes\n\t\tvar isCommitmentZero;\n\t\tisCommitmentZero = IsZero()(in <== commitments[i]);\n\t\t\n\t\tvar isHashEqual;\n\t\tisHashEqual = IsEqual()(in <== [commitments[i], (1 - isCommitmentZero) * calculatedHash /* ensure when commitment is 0, compare with 0 */]);\n\t\t\n\t\tisHashEqual === 1;\n\t}\n}\n\n```","x":1380,"y":3640,"width":1260,"height":600},
		{"id":"038a8bb798636582","type":"text","text":"### CheckSum\nCheck that the sum of input equals to the sum of output\n```c\ntemplate CheckSum(numInputs, numOutputs) {\n\tsignal input inputValues[numInputs];\n\tsignal input outputValues[numOutputs];\n\t\n\tvar sumInputs = 0;\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tsumInputs = sumInputs + inputValues[i];\n\t}\n\tvar sumOutputs = 0;\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tsumOutputs = sumOutputs + outputValues[i];\n\t}\n\t\n\tvar isSumEqual;\n\tisSumEqual = IsEqual()(in <== [sumInputs, sumOutputs]);\n\t\n\tisSumEqual === 1;\n}\n```","x":1380,"y":4280,"width":580,"height":520},
		{"id":"17193362f618d1ed","type":"text","text":"### Anon nullifier Circuit\n#### Compute\n```\n(sender_pub_k) <- sender_private_key\nInput_UTXO' = hash(value_in, salt, sender_pub_k)\nOutput_UTXO' = hash(value_out, salt, sender_pub_k/receiver_pub_k)\nNullifier' = hash(value_in, salt, sender_priv_k)\n```\n#### Verify\n```\nInput_UTXO' == Input_UTXO\nOutput_UTXO' == Output_UTXO\nNullifier' == Nullifier\nvalue_in == value_out\nsender_pub -> sender_private_key\nCheckSMTProof(SMT_root, Merkle_proof, enabled)\n```","x":1690,"y":1600,"width":620,"height":500,"color":"3"},
		{"id":"c488bf63101cd64b","type":"text","text":"### Public Inputs\n**Nullifier**\n**Output UTXOs**\n**SMT root**\n**enabled**","x":1875,"y":1360,"width":250,"height":180,"color":"4"},
		{"id":"11cb19d403837f49","type":"text","text":"### Validity : *{0, 1}*","x":2360,"y":1820,"width":250,"height":60,"color":"1"},
		{"id":"9dbd2f111976fdb3","type":"text","text":"### Private Inputs\n**Input UTXOs**\n**Input values, salt**\n**Output values, salt**\n**Sender Private Key**\n**Receiver Public key**\n**Merkle Proof**","x":1380,"y":1730,"width":250,"height":240,"color":"4"},
		{"id":"9334905d2c091515","x":1380,"y":4840,"width":1240,"height":660,"type":"text","text":"### CheckNullifiers\nCalculate the nullifier hash depending on the values, salts, public key and compare it to the nullifier \n```ts\ntemplate CheckNullifiers(numInputs) {\n\tsignal input nullifiers[numInputs];\n\tsignal input values[numInputs];\n\tsignal input salts[numInputs];\n\t// must be properly hashed and trimmed to be compatible with the BabyJub curve.\n\t// Reference: https://github.com/iden3/circomlib/blob/master/test/babyjub.js#L103\n\tsignal input ownerPrivateKey;\n\t\n\t// calculate the nullifier values from the input values\n\t\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tvar calculatedHash;\n\t\tcalculatedHash = Poseidon(3)(inputs <== [values[i], salts[i], ownerPrivateKey]);\n\t\t\n\t\t// check that the nullifiers match the calculated hashes\n\t\tvar isNullifierZero;\n\t\tisNullifierZero = IsZero()(in <== nullifiers[i]);\n\t\t\n\t\tvar isHashEqual;\n\t\tisHashEqual = IsEqual()(in <== [nullifiers[i], (1 - isNullifierZero) * calculatedHash /* ensure when nullifier is 0, compare with 0 */]);\n\t\t\n\t\tisHashEqual === 1;\n\t}\n}\n```"},
		{"id":"ed6049966aa8ce8d","x":1391,"y":5560,"width":1229,"height":500,"type":"text","text":"### CheckSMTProof\n```ts\ntemplate CheckSMTProof(numInputs, nSMTLevels) {\n\tsignal input leafNodeIndexes[numInputs];\n\tsignal input leafNodeValues[numInputs];\n\tsignal input root;\n\tsignal input merkleProof[numInputs][nSMTLevels];\n\tsignal input enabled[numInputs];\n\t\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tvar siblings[nSMTLevels];\n\t\tfor (var j = 0; j < nSMTLevels; j++) {\n\t\t\tsiblings[j] = merkleProof[i][j];\n\t\t}\n\t\t// The old values are only used in exclusion proofs. \n\t\t// As such they are always 0 for inclusion proofs.\n\t\t// TODO: update when exclusion proofs are supported\n\t\tSMTVerifier(nSMTLevels)(enabled <== enabled[i], root <== root, siblings <== siblings, key <== leafNodeIndexes[i], value <== leafNodeValues[i], fnc <== 0 /* 0: inclusion proof, 1: exclusion proof */, oldKey <== 0, oldValue <== 0, isOld0 <== 0);\n\t}\n}\n```"},
		{"id":"c8bd258713e348d8","type":"text","text":"### Prepare proof\n```ts\nasync function prepareProof(\n  circuit: any,\n  provingKey: any,\n  signer: User,\n  inputs: UTXO[],\n  _nullifiers: UTXO[],\n  outputs: UTXO[],\n  root: BigInt,\n  merkleProof: BigInt[][],\n  owners: User[],\n  lockDelegate?: string,\n) {\n  const nullifiers = _nullifiers.map((nullifier) => nullifier.hash) as [\n    BigNumberish,\n    BigNumberish,\n  ];\n  const inputCommitments: BigNumberish[] = inputs.map(\n    (input) => input.hash,\n  ) as BigNumberish[];\n  const inputValues = inputs.map((input) => BigInt(input.value || 0n));\n  const inputSalts = inputs.map((input) => input.salt || 0n);\n  const outputCommitments: BigNumberish[] = outputs.map(\n    (output) => output.hash,\n  ) as BigNumberish[];\n  const outputValues = outputs.map((output) => BigInt(output.value || 0n));\n  const outputOwnerPublicKeys: BigNumberish[][] = owners.map(\n    (owner) => owner.babyJubPublicKey,\n  ) as BigNumberish[][];\n\n  const startWitnessCalculation = Date.now();\n  const inputObj: any = {\n    nullifiers,\n    inputCommitments,\n    inputValues,\n    inputSalts,\n    inputOwnerPrivateKey: signer.formattedPrivateKey,\n    root,\n    enabled: nullifiers.map((n) => (n !== 0n ? 1 : 0)),\n    merkleProof,\n    outputCommitments,\n    outputValues,\n    outputSalts: outputs.map((output) => output.salt || 0n),\n    outputOwnerPublicKeys,\n  };\n  if (lockDelegate) {\n    inputObj[\"lockDelegate\"] = ethers.toBigInt(lockDelegate);\n  }\n\n  const witness = await circuit.calculateWTNSBin(inputObj, true);\n  const timeWithnessCalculation = Date.now() - startWitnessCalculation;\n\n  const startProofGeneration = Date.now();\n  const { proof, publicSignals } = (await groth16.prove(\n    provingKey,\n    witness,\n  )) as { proof: BigNumberish[]; publicSignals: BigNumberish[] };\n  const timeProofGeneration = Date.now() - startProofGeneration;\n\n  console.log(\n    `Witness calculation time: ${timeWithnessCalculation}ms. Proof generation time: ${timeProofGeneration}ms.`,\n  );\n\n  const encodedProof = encodeProof(proof);\n  return {\n    inputCommitments,\n    outputCommitments,\n    encodedProof,\n  };\n}\n\n```","x":-2040,"y":2685,"width":775,"height":1555},
		{"id":"8b2f60a7633d605c","type":"text","text":"### doTransfer\n```ts\nasync function doTransfer(\n\tsigner: User,\n\tinputs: UTXO[],\n\t_nullifiers: UTXO[],\n\toutputs: UTXO[],\n\troot: BigInt,\n\tmerkleProofs: BigInt[][],\n\towners: User[],\n\tlockDelegate?: User,\n  ) {\n    let nullifiers: BigNumberish[];\n    let outputCommitments: BigNumberish[];\n    let encodedProof: any;\n    const circuitToUse = lockDelegate\n\t\t? circuitForLocked\n\t\t: inputs.length > 2\n\t\t\t? batchCircuit\n\t\t\t: circuit;\n    const provingKeyToUse = lockDelegate\n\t\t? provingKeyForLocked\n\t\t: inputs.length > 2\n\t\t\t? batchProvingKey\n\t\t\t: provingKey;\n    const result = await prepareProof(\n\t\tcircuitToUse,\n\t\tprovingKeyToUse,\n\t\tsigner,\n\t\tinputs,\n\t\t_nullifiers,\n\t\toutputs,\n\t\troot,\n\t\tmerkleProofs,\n\t\towners,\n\t\tlockDelegate?.ethAddress,\n    );\n    nullifiers = _nullifiers.map(\n\t\t(nullifier) => nullifier.hash,\n    ) as BigNumberish[];\n    outputCommitments = result.outputCommitments;\n    encodedProof = result.encodedProof;\n\n    const txResult = await sendTx(\n\t\tsigner,\n\t\tnullifiers,\n\t\toutputCommitments,\n\t\troot,\n\t\tencodedProof,\n\t\tlockDelegate !== undefined,\n    );\n    // add the clear text value so that it can be used by tests to compare with the decrypted value\n    return {\n\t\ttxResult,\n\t\texpectedPlainText: outputs.reduce((acc, o, i) => {\n\t\t\tacc.push(BigInt(o.value || 0n) as BigNumberish);\n\t\t\tacc.push((o.salt || 0n) as BigNumberish);\n\t\t\treturn acc;\n\t\t}, [] as BigNumberish[]),\n    };\n}\n```","x":-1120,"y":2920,"width":680,"height":1320}
	],
	"edges":[
		{"id":"7f8ddf26c64be696","fromNode":"17193362f618d1ed","fromSide":"right","toNode":"11cb19d403837f49","toSide":"left"},
		{"id":"e87e59abba1c2d16","fromNode":"c488bf63101cd64b","fromSide":"bottom","toNode":"17193362f618d1ed","toSide":"top"},
		{"id":"5d7ad7de9331a45a","fromNode":"9dbd2f111976fdb3","fromSide":"right","toNode":"17193362f618d1ed","toSide":"left"},
		{"id":"3b029c9b2465ce56","fromNode":"8b2f60a7633d605c","fromSide":"left","toNode":"c8bd258713e348d8","toSide":"right"},
		{"id":"7d99c9cb5dea5388","fromNode":"d77fb10724b7e356","fromSide":"left","toNode":"8b2f60a7633d605c","toSide":"right"},
		{"id":"0b7d1098e8718f77","fromNode":"78e4cbe0b7e16d4d","fromSide":"left","toNode":"b488df16e3759c68","toSide":"left"},
		{"id":"ad22119033e7a214","fromNode":"78e4cbe0b7e16d4d","fromSide":"left","toNode":"eaa67def5447bb78","toSide":"left"},
		{"id":"be7b3e485a66bf62","fromNode":"78e4cbe0b7e16d4d","fromSide":"left","toNode":"038a8bb798636582","toSide":"left"},
		{"id":"62f0ca3686d91491","fromNode":"78e4cbe0b7e16d4d","fromSide":"left","toNode":"9334905d2c091515","toSide":"left"},
		{"id":"db233f0605c62686","fromNode":"78e4cbe0b7e16d4d","fromSide":"left","toNode":"ed6049966aa8ce8d","toSide":"left"}
	]
}