{
	"nodes":[
		{"id":"12b8d72d4e5f9200","type":"group","x":-3600,"y":2000,"width":3080,"height":1760,"color":"4","label":"Client"},
		{"id":"e4bd2276d11469e2","type":"group","x":-320,"y":1160,"width":1500,"height":3080,"color":"3","label":"In chain circuit"},
		{"id":"75e766f35b5b2c78","type":"text","text":"### Anon Circuit\n#### Compute\n```\n(sender_pub_k) <- sender_private_key\nInput_UTXO' = hash(value_in, salt, sender_pub_k)\nOutput_UTXO' = hash(value_out, salt, sender_pub_k/receiver_pub_k)\n```\n#### Verify\n```\nInput_UTXO' == Input_UTXO\nOutput_UTXO' == Output_UTXO\nvalue_in == value_out\nsender_pub -> sender_private_key\n```","x":190,"y":1380,"width":620,"height":440,"color":"3"},
		{"id":"1329e3a1e1dca271","type":"text","text":"### Private Inputs\n**Input values, salt**\n**Output values, salt**\n**Sender Private Key**\n**Receiver Public key**","x":-110,"y":1510,"width":250,"height":180,"color":"4"},
		{"id":"e50a093ec76ec549","type":"text","text":"### Validity : *{0, 1}*","x":850,"y":1570,"width":250,"height":60,"color":"1"},
		{"id":"e808ff165df64308","type":"text","text":"### Public Inputs\n**Input UTXOs**\n**Output UTXOs**","x":375,"y":1180,"width":250,"height":117,"color":"4"},
		{"id":"4881c3edc149476d","type":"text","text":"### Setup\nWe get the deployer, three users and circuit for proofs\n```ts\nlet [d, a, b, c] = await ethers.getSigners();\ndeployer = d;\nAlice = await newUser(a);\nBob = await newUser(b);\nCharlie = await newUser(c);\n\n({ deployer, zeto, erc20 } = await deployZeto(\"Zeto_Anon\"));\n\ncircuit = await loadCircuit(\"anon\");\n({ provingKeyFile: provingKey } = loadProvingKeys(\"anon\"));\n```","x":-2300,"y":2040,"width":1240,"height":420},
		{"id":"44d347189c31c136","type":"text","text":"### doTransfer\n```ts\nasync function doTransfer(\n    signer: User,\n    inputs: UTXO[],\n    outputs: UTXO[],\n    owners: User[],\n  ) {\n    let inputCommitments: BigNumberish[];\n    let outputCommitments: BigNumberish[];\n    let outputOwnerAddresses: AddressLike[];\n    let encodedProof: any;\n    let circuitToUse = circuit;\n    let provingKeyToUse = provingKey;\n    if (inputs.length > 2 || outputs.length > 2) {\n      circuitToUse = batchCircuit;\n      provingKeyToUse = batchProvingKey;\n    }\n    const result = await prepareProof(\n      circuitToUse,\n      provingKeyToUse,\n      signer,\n      inputs,\n      outputs,\n      owners,\n    );\n    inputCommitments = result.inputCommitments;\n    outputCommitments = result.outputCommitments;\n    outputOwnerAddresses = owners.map(\n      (owner) => owner.ethAddress || ZeroAddress,\n    ) as [AddressLike, AddressLike];\n    encodedProof = result.encodedProof;\n\n    return await sendTx(\n      signer,\n      inputCommitments,\n      outputCommitments,\n      encodedProof,\n    );\n  }\n```","x":-2640,"y":2640,"width":680,"height":880},
		{"id":"6e3c937521134976","type":"text","text":"### Transaction\n*Mint to Alice and transfer UTXOs honestly to Bob*\nFirst the authority mints UTXOs to Alice\n```ts\nconst startingBalance = await erc20.balanceOf(Alice.ethAddress);\n// first the authority mints UTXOs to Alice\nutxo1 = newUTXO(10, Alice);\nutxo2 = newUTXO(20, Alice);\nawait doMint(zeto, deployer, [utxo1, utxo2]);\n```\nThen Alice creates new UTXOs and initiate the transfer\n```ts\n// Alice proposes the output UTXOs\nconst _txo3 = newUTXO(25, Bob);\nutxo4 = newUTXO(5, Alice, _txo3.salt);\n\n// Alice transfers UTXOs to Bob\nconst result = await doTransfer(\n  Alice,\n  [utxo1, utxo2],\n  [_txo3, utxo4],\n  [Bob, Alice],\n);\n```\nBob obtain the UTXO from the transaction event and reconstruct them from off-chain secure message channels with Alice\n```ts\n// first obtain the UTXOs from the transaction event\nconst events = parseUTXOEvents(zeto, result);\nconst incomingUTXOs: any = events[0].outputs;\n\n// Bob uses the information received from Alice to reconstruct the UTXO sent to him\nconst receivedValue = 25;\nconst receivedSalt = _txo3.salt;\nconst hash = poseidonHash([\n  BigInt(receivedValue),\n  receivedSalt,\n  Bob.babyJubPublicKey[0],\n  Bob.babyJubPublicKey[1],\n]);\n```\nThe computed `hash` by Bob should be equal to the UTXO obained from the events\n```ts\nexpect(incomingUTXOs[0]).to.equal(hash);\n\n// now Bob can reconstruct the UTXO using the information received from Alice\nutxo3 = newUTXO(receivedValue, Bob, receivedSalt);\n```","x":-1800,"y":2500,"width":1240,"height":1160},
		{"id":"adeec999f9d93f5c","type":"text","text":"### Prepare proof\n```ts\nasync function prepareProof(\n  circuit: any,\n  provingKey: any,\n  signer: User,\n  inputs: UTXO[],\n  outputs: UTXO[],\n  owners: User[],\n) {\n  const inputCommitments: BigNumberish[] = inputs.map(\n    (input) => input.hash,\n  ) as BigNumberish[];\n  const inputValues = inputs.map((input) => BigInt(input.value || 0n));\n  const inputSalts = inputs.map((input) => input.salt || 0n);\n  const outputCommitments: BigNumberish[] = outputs.map(\n    (output) => output.hash,\n  ) as BigNumberish[];\n  const outputValues = outputs.map((output) => BigInt(output.value || 0n));\n  const outputSalts = outputs.map((o) => o.salt || 0n);\n  const outputOwnerPublicKeys: BigNumberish[][] = owners.map(\n    (owner) => owner.babyJubPublicKey || ZERO_PUBKEY,\n  ) as BigNumberish[][];\n  const otherInputs = stringifyBigInts({\n    inputOwnerPrivateKey: formatPrivKeyForBabyJub(signer.babyJubPrivateKey),\n  });\n\n  const startWitnessCalculation = Date.now();\n  const witness = await circuit.calculateWTNSBin(\n    {\n      inputCommitments,\n      inputValues,\n      inputSalts,\n      outputCommitments,\n      outputValues,\n      outputSalts,\n      outputOwnerPublicKeys,\n      ...otherInputs,\n    },\n    true,\n  );\n  const timeWitnessCalculation = Date.now() - startWitnessCalculation;\n\n  const startProofGeneration = Date.now();\n  const { proof, publicSignals } = (await groth16.prove(\n    provingKey,\n    witness,\n  )) as { proof: BigNumberish[]; publicSignals: BigNumberish[] };\n  const timeProofGeneration = Date.now() - startProofGeneration;\n  console.log(\n    `Witness calculation time: ${timeWitnessCalculation}ms, Proof generation time: ${timeProofGeneration}ms`,\n  );\n  const encodedProof = encodeProof(proof);\n  return {\n    inputCommitments,\n    outputCommitments,\n    encodedProof,\n  };\n}\n```","x":-3560,"y":2445,"width":775,"height":1270},
		{"id":"f22e63622d5f11ef","type":"text","text":"### CheckPositive\nCheck is the value is greater or equal to `0` \n```c\ntemplate CheckPositive(numOutputs) {\n\tsignal input outputValues[numOutputs];\n\t\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tvar greaterEqThanZero;\n\t\tgreaterEqThanZero = GreaterEqThan(100)(in <== [outputValues[i], 0]);\n\t\t\n\t\tgreaterEqThanZero === 1;\n\t}\n}\n```","x":-140,"y":2620,"width":580,"height":400},
		{"id":"54a9ddf04c4fa1b8","type":"text","text":"### CheckHashes\nCalculate the hash depending on the values, salts, public key and compare it to the commitment \n```c\ntemplate CheckHashes(numInputs) {\n\tsignal input commitments[numInputs];\n\tsignal input values[numInputs];\n\tsignal input salts[numInputs];\n\tsignal input ownerPublicKeys[numInputs][2];\n\t\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tvar calculatedHash;\n\t\tcalculatedHash = Poseidon(4)([values[i], salts[i], ownerPublicKeys[i][0], ownerPublicKeys[i][1]]);\n\t\t\n\t\t// check that the input commitments match the calculated hashes\n\t\tvar isCommitmentZero;\n\t\tisCommitmentZero = IsZero()(in <== commitments[i]);\n\t\t\n\t\tvar isHashEqual;\n\t\tisHashEqual = IsEqual()(in <== [commitments[i], (1 - isCommitmentZero) * calculatedHash /* ensure when commitment is 0, compare with 0 */]);\n\t\t\n\t\tisHashEqual === 1;\n\t}\n}\n\n```","x":-140,"y":3060,"width":1260,"height":600},
		{"id":"9f6e169717479ae2","type":"text","text":"### CheckSum\nCheck that the sum of input equals to the sum of output\n```c\ntemplate CheckSum(numInputs, numOutputs) {\n\tsignal input inputValues[numInputs];\n\tsignal input outputValues[numOutputs];\n\t\n\tvar sumInputs = 0;\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tsumInputs = sumInputs + inputValues[i];\n\t}\n\tvar sumOutputs = 0;\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tsumOutputs = sumOutputs + outputValues[i];\n\t}\n\t\n\tvar isSumEqual;\n\tisSumEqual = IsEqual()(in <== [sumInputs, sumOutputs]);\n\t\n\tisSumEqual === 1;\n}\n```","x":-140,"y":3700,"width":580,"height":520},
		{"id":"a66be3acda148565","type":"text","text":"```c\ntemplate Zeto(nInputs, nOutputs) {\n\t//Public-------------------------------------\n\tsignal input inputCommitments[nInputs];\n\tsignal input outputCommitments[nOutputs];\n\t//-------------------------------------------\n\n\t//Private------------------------------------\n\tsignal input inputValues[nInputs];\n\tsignal input inputSalts[nInputs];\n\tsignal input outputValues[nOutputs];\n\tsignal input outputSalts[nOutputs];\n\n\tsignal input outputOwnerPublicKeys[nOutputs][2];\n\tsignal input inputOwnerPrivateKey;\n\t//-------------------------------------------\n\t\n\t//Get the public owner key fom it's private key\n\tvar inputOwnerPubKeyAx, inputOwnerPubKeyAy;\n\t(inputOwnerPubKeyAx, inputOwnerPubKeyAy) = BabyPbk()(in <== inputOwnerPrivateKey);\n\tvar inputOwnerPublicKeys[nInputs][2];\n\tfor (var i = 0; i < nInputs; i++) {\n\t\tinputOwnerPublicKeys[i]= [inputOwnerPubKeyAx, inputOwnerPubKeyAy];\n\t}\n\t//-------------------------------------------\n\t\n\t\n\tCheckPositive(nOutputs)(outputValues <== outputValues);\n\tCheckHashes(nInputs)(commitments <== inputCommitments, values <== inputValues, salts <== inputSalts, ownerPublicKeys <== inputOwnerPublicKeys);\n\tCheckHashes(nOutputs)(commitments <== outputCommitments, values <== outputValues, salts <== outputSalts, ownerPublicKeys <== outputOwnerPublicKeys);\n\tCheckSum(nInputs, nOutputs)(inputValues <== inputValues, outputValues <== outputValues);\n}\n```","x":-140,"y":1900,"width":1300,"height":680}
	],
	"edges":[
		{"id":"720f0ef716d72955","fromNode":"e808ff165df64308","fromSide":"bottom","toNode":"75e766f35b5b2c78","toSide":"top"},
		{"id":"f7c9fc5d57b83be0","fromNode":"1329e3a1e1dca271","fromSide":"right","toNode":"75e766f35b5b2c78","toSide":"left"},
		{"id":"bafd093a48a59e84","fromNode":"75e766f35b5b2c78","fromSide":"right","toNode":"e50a093ec76ec549","toSide":"left"},
		{"id":"4e39e299fa13ab9b","fromNode":"a66be3acda148565","fromSide":"left","toNode":"f22e63622d5f11ef","toSide":"left"},
		{"id":"c5ba8661d041a676","fromNode":"a66be3acda148565","fromSide":"left","toNode":"54a9ddf04c4fa1b8","toSide":"left"},
		{"id":"cc8038a24473109d","fromNode":"a66be3acda148565","fromSide":"left","toNode":"9f6e169717479ae2","toSide":"left"},
		{"id":"7418df98ffd6185b","fromNode":"6e3c937521134976","fromSide":"left","toNode":"44d347189c31c136","toSide":"right"},
		{"id":"5b4832d4f08e3ccc","fromNode":"44d347189c31c136","fromSide":"left","toNode":"adeec999f9d93f5c","toSide":"right"}
	]
}