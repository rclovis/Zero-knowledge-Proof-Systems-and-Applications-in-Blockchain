{
	"nodes":[
		{"id":"75e766f35b5b2c78","type":"text","text":"### Anon Circuit\n#### Compute\n```\n(sender_pub_k) <- sender_private_key\nInput_UTXO' = hash(value_in, salt, sender_pub_k)\nOutput_UTXO' = hash(value_out, salt, sender_pub_k/receiver_pub_k)\n```\n#### Verify\n```\nInput_UTXO' == Input_UTXO\nOutput_UTXO' == Output_UTXO\nvalue_in == value_out\nsender_pub -> sender_private_key\n```","x":-200,"y":-80,"width":620,"height":440,"color":"3"},
		{"id":"e808ff165df64308","type":"text","text":"### Public Inputs\n**Input UTXOs**\n**Output UTXOs**","x":-15,"y":-240,"width":250,"height":117,"color":"4"},
		{"id":"e50a093ec76ec549","type":"text","text":"### Validity : *{0, 1}*","x":460,"y":110,"width":250,"height":60,"color":"1"},
		{"id":"1329e3a1e1dca271","type":"text","text":"### Private Inputs\n**Input values, salt**\n**Output values, salt**\n**Sender Private Key**\n**Receiver Public key**","x":-500,"y":50,"width":250,"height":180,"color":"4"},
		{"id":"a66be3acda148565","type":"text","text":"```c\ntemplate Zeto(nInputs, nOutputs) {\n\t//Public-------------------------------------\n\tsignal input inputCommitments[nInputs];\n\tsignal input outputCommitments[nOutputs];\n\t//-------------------------------------------\n\n\t//Private------------------------------------\n\tsignal input inputValues[nInputs];\n\tsignal input inputSalts[nInputs];\n\tsignal input outputValues[nOutputs];\n\tsignal input outputSalts[nOutputs];\n\n\tsignal input outputOwnerPublicKeys[nOutputs][2];\n\tsignal input inputOwnerPrivateKey;\n\t//-------------------------------------------\n\t\n\t//Get the public owner key fom it's private key\n\tvar inputOwnerPubKeyAx, inputOwnerPubKeyAy;\n\t(inputOwnerPubKeyAx, inputOwnerPubKeyAy) = BabyPbk()(in <== inputOwnerPrivateKey);\n\tvar inputOwnerPublicKeys[nInputs][2];\n\tfor (var i = 0; i < nInputs; i++) {\n\t\tinputOwnerPublicKeys[i]= [inputOwnerPubKeyAx, inputOwnerPubKeyAy];\n\t}\n\t//-------------------------------------------\n\t\n\t\n\tCheckPositive(nOutputs)(outputValues <== outputValues);\n\tCheckHashes(nInputs)(commitments <== inputCommitments, values <== inputValues, salts <== inputSalts, ownerPublicKeys <== inputOwnerPublicKeys);\n\tCheckHashes(nOutputs)(commitments <== outputCommitments, values <== outputValues, salts <== outputSalts, ownerPublicKeys <== outputOwnerPublicKeys);\n\tCheckSum(nInputs, nOutputs)(inputValues <== inputValues, outputValues <== outputValues);\n}\n```","x":-200,"y":440,"width":1300,"height":680},
		{"id":"f22e63622d5f11ef","type":"text","text":"### CheckPositive\nCheck is the value is greater or equal to `0` \n```c\ntemplate CheckPositive(numOutputs) {\n\tsignal input outputValues[numOutputs];\n\t\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tvar greaterEqThanZero;\n\t\tgreaterEqThanZero = GreaterEqThan(100)(in <== [outputValues[i], 0]);\n\t\t\n\t\tgreaterEqThanZero === 1;\n\t}\n}\n```","x":-200,"y":1160,"width":580,"height":400},
		{"id":"54a9ddf04c4fa1b8","type":"text","text":"### CheckHashes\nCalculate the hash depending on the values, salts, public key and compare it to the commitment \n```c\ntemplate CheckHashes(numInputs) {\n  signal input commitments[numInputs];\n  signal input values[numInputs];\n  signal input salts[numInputs];\n  signal input ownerPublicKeys[numInputs][2];\n\n  for (var i = 0; i < numInputs; i++) {\n    var calculatedHash;\n    calculatedHash = Poseidon(4)([values[i], salts[i], ownerPublicKeys[i][0], ownerPublicKeys[i][1]]);\n\n    // check that the input commitments match the calculated hashes\n    var isCommitmentZero;\n    isCommitmentZero = IsZero()(in <== commitments[i]);\n\n    var isHashEqual;\n    isHashEqual = IsEqual()(in <== [commitments[i], (1 - isCommitmentZero) * calculatedHash /* ensure when commitment is 0, compare with 0 */]);\n\n    isHashEqual === 1;\n  }\n}\n\n```","x":-200,"y":1600,"width":1240,"height":600},
		{"id":"9f6e169717479ae2","type":"text","text":"### CheckHashes\nCheck that the sum of input equals to the sum of output\n```c\ntemplate CheckSum(numInputs, numOutputs) {\n\tsignal input inputValues[numInputs];\n\tsignal input outputValues[numOutputs];\n\t\n\tvar sumInputs = 0;\n\tfor (var i = 0; i < numInputs; i++) {\n\t\tsumInputs = sumInputs + inputValues[i];\n\t}\n\tvar sumOutputs = 0;\n\tfor (var i = 0; i < numOutputs; i++) {\n\t\tsumOutputs = sumOutputs + outputValues[i];\n\t}\n\t\n\tvar isSumEqual;\n\tisSumEqual = IsEqual()(in <== [sumInputs, sumOutputs]);\n\t\n\tisSumEqual === 1;\n}\n```","x":-200,"y":2240,"width":580,"height":520},
		{"id":"6e3c937521134976","type":"text","text":"### Transaction\n*10 UTXOs honestly to Bob & Charlie then withdraw*\n```ts\n  it(\"(batch) mint to Alice and batch transfer 10 UTXOs honestly to Bob & Charlie then withdraw should succeed\", async function () {\n    // first mint the tokens for batch testing\n    const inputUtxos = [];\n    for (let i = 0; i < 10; i++) {\n      // mint 10 utxos\n      inputUtxos.push(newUTXO(1, Alice));\n    }\n    await doMint(zeto, deployer, inputUtxos);\n\n    const aliceUTXOsToBeWithdrawn = [\n      newUTXO(1, Alice),\n      newUTXO(1, Alice),\n      newUTXO(1, Alice),\n    ];\n    // Alice proposes the output UTXOs, 1 utxo to bob, 1 utxo to charlie and 3 utxos to alice\n    const _bOut1 = newUTXO(6, Bob);\n    const _bOut2 = newUTXO(1, Charlie);\n\n    const outputUtxos = [_bOut1, _bOut2, ...aliceUTXOsToBeWithdrawn];\n    const outputOwners = [Bob, Charlie, Alice, Alice, Alice];\n    const inflatedOutputUtxos = [...outputUtxos];\n    const inflatedOutputOwners = [...outputOwners];\n    for (let i = 0; i < 10 - outputUtxos.length; i++) {\n      inflatedOutputUtxos.push(ZERO_UTXO);\n      inflatedOutputOwners.push(Bob);\n    }\n\n    // Alice transfers UTXOs to Bob and Charlie\n    const result = await doTransfer(\n      Alice,\n      inputUtxos,\n      inflatedOutputUtxos,\n      inflatedOutputOwners,\n    );\n\n    const events = parseUTXOEvents(zeto, result);\n    const incomingUTXOs: any = events[0].outputs;\n    // check the non-empty output hashes are correct\n    for (let i = 0; i < outputUtxos.length; i++) {\n      // Bob uses the information received from Alice to reconstruct the UTXO sent to him\n      const receivedValue = outputUtxos[i].value;\n      const receivedSalt = outputUtxos[i].salt;\n      const hash = poseidonHash([\n        BigInt(receivedValue),\n        receivedSalt,\n        outputOwners[i].babyJubPublicKey[0],\n        outputOwners[i].babyJubPublicKey[1],\n      ]);\n      expect(incomingUTXOs[i]).to.equal(hash);\n    }\n\n    // check empty hashes are empty\n    for (let i = outputUtxos.length; i < 10; i++) {\n      expect(incomingUTXOs[i]).to.equal(0);\n    }\n\n    // mint sufficient balance in Zeto contract address for Alice to withdraw\n    const mintTx = await erc20.connect(deployer).mint(zeto, 3);\n    await mintTx.wait();\n    const startingBalance = await erc20.balanceOf(Alice.ethAddress);\n\n    // Alice generates the nullifiers for the UTXOs to be spent\n    const inflatedWithdrawInputs = [...aliceUTXOsToBeWithdrawn];\n\n    // Alice generates inclusion proofs for the UTXOs to be spent\n\n    for (let i = aliceUTXOsToBeWithdrawn.length; i < 10; i++) {\n      inflatedWithdrawInputs.push(ZERO_UTXO);\n    }\n    const { inputCommitments, outputCommitments, encodedProof } =\n      await prepareWithdrawProof(Alice, inflatedWithdrawInputs, ZERO_UTXO);\n\n    // Alice withdraws her UTXOs to ERC20 tokens\n    const tx = await zeto\n      .connect(Alice.signer)\n      .withdraw(3, inputCommitments, outputCommitments[0], encodedProof, \"0x\");\n    await tx.wait();\n\n    // Alice checks her ERC20 balance\n    const endingBalance = await erc20.balanceOf(Alice.ethAddress);\n    expect(endingBalance - startingBalance).to.be.equal(3);\n  });\n```","x":-1680,"y":960,"width":1240,"height":1720},
		{"id":"e4a948493a92dca7","type":"text","text":"### Utils\n#### New user\n```ts\nexport async function newUser(signer: Signer) {\n  const { privKey, pubKey } = genKeypair();\n  const formattedPrivateKey = formatPrivKeyForBabyJub(privKey);\n\n  return {\n    signer,\n    ethAddress: await signer.getAddress(),\n    babyJubPrivateKey: privKey,\n    babyJubPublicKey: pubKey,\n    formattedPrivateKey,\n  };\n}\n```\n#### New UTXO\n```ts\nexport function newUTXO(value: number, owner: User, salt?: BigInt): UTXO {\n  if (!salt) salt = newSalt();\n  const hash = poseidonHash4([\n    BigInt(value),\n    salt,\n    owner.babyJubPublicKey[0],\n    owner.babyJubPublicKey[1],\n  ]);\n  return { value, hash, salt };\n}\n```\n#### New nullifier\n```ts\nexport function newNullifier(utxo: UTXO, owner: User): UTXO {\n  const hash = poseidonHash3([\n    BigInt(utxo.value!),\n    utxo.salt,\n    owner.formattedPrivateKey,\n  ]);\n  return { value: utxo.value, hash, salt: utxo.salt };\n}\n```\n#### Mint\n```ts\nexport async function doMint(\n  zetoTokenContract: any,\n  minter: Signer,\n  outputs: UTXO[],\n  gasHistories?: number[],\n): Promise<ContractTransactionReceipt> {\n  const outputCommitments = outputs.map(\n    (output) => output.hash,\n  ) as BigNumberish[];\n  const tx = await zetoTokenContract\n    .connect(minter)\n    .mint(outputCommitments, \"0x\");\n  const result = await tx.wait();\n  console.log(`Method mint() complete. Gas used: ${result?.gasUsed}`);\n  if (result?.gasUsed && Array.isArray(gasHistories)) {\n    gasHistories.push(result?.gasUsed);\n  }\n  return result;\n}\n```\n#### Deposit\n```ts\nexport async function doDeposit(\n  zetoTokenContract: any,\n  depositUser: Signer,\n  amount: any,\n  commitment: any,\n  proof: any,\n  gasHistories?: number[],\n): Promise<ContractTransactionReceipt> {\n  const tx = await zetoTokenContract\n    .connect(depositUser)\n    .deposit(amount, commitment, proof, \"0x\");\n  const result = await tx.wait();\n  console.log(`Method deposit() complete. Gas used: ${result?.gasUsed}`);\n  if (result?.gasUsed && Array.isArray(gasHistories)) {\n    gasHistories.push(result?.gasUsed);\n  }\n  return result;\n}\n```\n#### Withdraw\n```ts\nexport async function doWithdraw(\n  zetoTokenContract: any,\n  withdrawUser: Signer,\n  amount: any,\n  nullifiers: any,\n  commitment: any,\n  root: any,\n  proof: any,\n  gasHistories?: number[],\n): Promise<ContractTransactionReceipt> {\n  const tx = await zetoTokenContract\n    .connect(withdrawUser)\n    .withdraw(amount, nullifiers, commitment, root, proof);\n  const result = await tx.wait();\n  console.log(`Method withdraw() complete. Gas used: ${result?.gasUsed}`);\n  if (result?.gasUsed && Array.isArray(gasHistories)) {\n    gasHistories.push(result?.gasUsed);\n  }\n  return result;\n}\n```","x":-964,"y":3126,"width":1724,"height":1354}
	],
	"edges":[
		{"id":"720f0ef716d72955","fromNode":"e808ff165df64308","fromSide":"bottom","toNode":"75e766f35b5b2c78","toSide":"top"},
		{"id":"f7c9fc5d57b83be0","fromNode":"1329e3a1e1dca271","fromSide":"right","toNode":"75e766f35b5b2c78","toSide":"left"},
		{"id":"bafd093a48a59e84","fromNode":"75e766f35b5b2c78","fromSide":"right","toNode":"e50a093ec76ec549","toSide":"left"},
		{"id":"4e39e299fa13ab9b","fromNode":"a66be3acda148565","fromSide":"left","toNode":"f22e63622d5f11ef","toSide":"left"},
		{"id":"c5ba8661d041a676","fromNode":"a66be3acda148565","fromSide":"left","toNode":"54a9ddf04c4fa1b8","toSide":"left"},
		{"id":"cc8038a24473109d","fromNode":"a66be3acda148565","fromSide":"left","toNode":"9f6e169717479ae2","toSide":"left"}
	]
}